<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <script src="https://cdn.jsdelivr.net/npm/cardlink"></script>
  <link rel="stylesheet" href="/css/_common/codeblock.css">
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<link rel="stylesheet" href="/_data/styles.">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>
  <script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("http://zxiaoxuan.cn"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>

<script src="https://cdn.jsdelivr.net/npm/basiclightbox@5.0.4/dist/basicLightbox.min.js"></script>
<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yeluogui.cloud","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
<meta property="og:type" content="website">
<meta property="og:title" content="穿过长长的隧道，便是雪国">
<meta property="og:url" content="http://yeluogui.cloud/index.html">
<meta property="og:site_name" content="穿过长长的隧道，便是雪国">
<meta property="og:description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="叶落归">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yeluogui.cloud/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  
  <title>穿过长长的隧道，便是雪国</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">穿过长长的隧道，便是雪国</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书单</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-film fa-fw"></i>影视</a>

  </li>
        <li class="menu-item menu-item-diary">

    <a href="/diary/" rel="section"><i class="fa fa-book-open fa-fw"></i>日记</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="fa fa-camera fa-fw"></i>画廊</a>

  </li>
        <li class="menu-item menu-item-bake">

    <a href="/bake/" rel="section"><i class="fa fa-birthday-cake fa-fw"></i>烘焙</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-steam">

    <a href="/steamgames/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a>

  </li>
        <li class="menu-item menu-item-lab">

    <a href="/lab/" rel="section"><i class="fa fa-flask fa-fw"></i>实验室</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yeluogui.cloud/2026/01/25/%E5%9F%8E%E5%B8%82%E4%B8%8E%E7%8B%97%E2%80%94%E2%80%94%E7%A7%98%E9%B2%81%E6%AE%8B%E9%85%B7%E9%9D%92%E6%98%A5%E7%89%A9%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="叶落归">
      <meta itemprop="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="穿过长长的隧道，便是雪国">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/25/%E5%9F%8E%E5%B8%82%E4%B8%8E%E7%8B%97%E2%80%94%E2%80%94%E7%A7%98%E9%B2%81%E6%AE%8B%E9%85%B7%E9%9D%92%E6%98%A5%E7%89%A9%E8%AF%AD/" class="post-title-link" itemprop="url">城市与狗——秘鲁残酷青春物语</a>
        </h2>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-25 14:48:27 / 修改时间：16:44:53" itemprop="dateCreated datePublished" datetime="2026-01-25T14:48:27+08:00">2026-01-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%87%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">文学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <table>
<thead>
<tr>
<th align="left">角色</th>
<th align="left">身份&#x2F;绰号</th>
<th align="left">关系核心</th>
<th align="left">关键关联人物</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>“美洲豹” (Jaguar)</strong></td>
<td align="left">士官生，地下首领</td>
<td align="left"><strong>暴力权威</strong>，维护“圈子”规则</td>
<td align="left">博阿、里卡多·阿拉纳、阿尔贝托（敌）、特莱莎（后期女友）</td>
</tr>
<tr>
<td align="left"><strong>“诗人”阿尔贝托 (Alberto)</strong></td>
<td align="left">士官生，叙事者之一</td>
<td align="left"><strong>反抗者&#x2F;观察者</strong>，试图用文字对抗暴力</td>
<td align="left">美洲豹（敌）、“奴隶”（友）、特莱莎（前期女友）</td>
</tr>
<tr>
<td align="left"><strong>“奴隶”里卡多·阿拉纳</strong></td>
<td align="left">士官生，受害者</td>
<td align="left"><strong>暴力的承受者</strong>，纯洁与软弱的象征</td>
<td align="left">美洲豹（施暴者）、阿尔贝托（保护者&#x2F;朋友）</td>
</tr>
<tr>
<td align="left"><strong>博阿 (Boa)</strong></td>
<td align="left">士官生，“圈子”成员</td>
<td align="left">暴力的执行者</td>
<td align="left">美洲豹（领袖）、其他“圈子”成员</td>
</tr>
</tbody></table>
<p>刚刚看完《城市与狗》，结局才揭示那个旁白中出现的和特莱莎出现互动的人物是“美洲豹”。在残酷的秘鲁社会更为冷酷的军事社会中，军事学校的“美洲豹”用暴力在四年级中建立了秩序，想带领大家成为“男子汉”，可是在一次偶然的偷试卷行动失败后，美洲豹借助一次校外的军事演习用实弹击中了在这个残酷的军事社会中仅仅是因为不会打架，良善老实的“告密者”“奴隶”</p>
<p>围绕着校外的人物特莱莎，“诗人”的前女友和日后“美洲豹”妻子，借由他们和特莱莎之间时空完全切割的爱情，将两个色彩鲜明的人物彻底分割。诗人帮其他同学写情歌，贩卖自己写的小黄书，是这个残酷森严的暴力社会中用文字解决问题的浪漫者，在他与特莱莎的爱情中也充分体现了其特质。所有人都在欺负“奴隶”，曾经的“诗人”也随波逐流欺负过“奴隶”，可当诗人帮助奴隶偷了一次衣服，帮他解决了一次问题，两个人才成为了朋友。也正是因此“诗人”冒着自己被开除的风险，冒着自己被所有同学唾弃为“告密者”的风险，主动去发掘“奴隶”死亡的真相，并且不顾风险的去控告美洲豹。</p>
<p>一场残酷的青春物语，在大男子主义的军事学校的强烈压迫下，所有人异化了情感，用暴力和粗俗作为唯一的语言，作为“男子汉”吸烟饮酒打架霸凌。美洲豹代表了这一暴力的极端，而诗人用人性挑战了这一体系。最后美洲豹的自首，是他良心发现了，察觉到了所有人对他的不信任才会精神世界崩塌，但是他看不到在这个暴力环环相扣的社会，他在年级里建立的暴力只是体系下暴力的一环，正是这样的暴力诞生了惨剧诞生了“奴隶”</p>
<p>在潮湿始终处于雨季的秘鲁社会，就像博阿养的狗一样，在极端的社会暴力之下存在的个人的爱最终会被轻易泯灭，残酷的青春物语谢幕，“诗人”的妥协和“美洲豹”如预言一样的平庸堕落，像追赶那些虚无缥缈的梦一样，在<strong>莱昂西奥·普拉多军事学校</strong>的故事最后像烟尘一样散去。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yeluogui.cloud/2026/01/22/%E6%88%98%E4%BA%89%E4%B8%8E%E5%92%8C%E5%B9%B3%E2%80%94%E2%80%94%E8%87%AA%E7%94%B1%E6%84%8F%E5%BF%97%E4%B8%8E%E5%BF%85%E7%84%B6%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="叶落归">
      <meta itemprop="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="穿过长长的隧道，便是雪国">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/22/%E6%88%98%E4%BA%89%E4%B8%8E%E5%92%8C%E5%B9%B3%E2%80%94%E2%80%94%E8%87%AA%E7%94%B1%E6%84%8F%E5%BF%97%E4%B8%8E%E5%BF%85%E7%84%B6%E6%80%A7/" class="post-title-link" itemprop="url">战争与和平——自由意志与必然性</a>
        </h2>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-22 00:13:23 / 修改时间：00:13:34" itemprop="dateCreated datePublished" datetime="2026-01-22T00:13:23+08:00">2026-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%87%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">文学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://s3.bmp.ovh/imgs/2026/01/21/17b3eb8723a1dc7a.png">历经两个月终于啃完了战争与和平这本书，震撼之余为了保留封存这份感受，赶紧记录一下写篇博客，从何写起呢？我更想从他的哲学思辨开始，再讨论我比较喜欢的故事吧</p>
<h2 id="自由和必然性"><a href="#自由和必然性" class="headerlink" title="自由和必然性"></a>自由和必然性</h2><p>书中几乎每一册或者说每一册的每一部都在提及，苹果落地可以说是期望他落地孩子的功劳，战争可以说是君主发动。但是实际上真的是这样吗？苹果落地可能是根基已经不稳，或者说万有引力强烈地撕扯，亦或者是枝干撑不起硕果，或者说平日里温柔的微风变成了狂风。那么战争的必然就不是由于君主的自由意志，他象征着的是已经受到了束缚的历史和人民群众乃至其生活的影响</p>
<blockquote>
<p>苹果成熟了就掉下来，它为什么掉下来?是因为地心引力吗?是因为茎干枯了吗?是因为太阳把它晒干了吗?是因为它太重了吗?是因为风吹了它吗?是因为树下有一个小孩想吃它吗?</p>
<p>这都不是原因。这一切只是每个重大的、有机的、自发的事件得以实现的各种条件的偶合。植物学家认为苹果之所以落下来,是由于细胞组织腐败等等原因，站在树下的小孩却认为，因为他想吃苹果，并且为此做了祈祷,所以它才掉下来，植物学家和小孩都同样正确。说拿破仑去莫斯科是因为他愿意去，说他毁灭是因为亚历山大希望他毁灭,这样说的人，也对也不对，同样，一座被刨倒的一百万普特的山之所以倒下来，是由于最后一个工人用十字镐刨了最后一下,说这话的人也对也不对。在各种历史事件中，那些所谓伟大的人物，不过是给事件命名的标签罢了，他们也正如标签一样，与事件本身关系极少</p>
</blockquote>
<p>托尔斯泰用不计其数这样的例子，推证了其说法。历史是无数微小的人民群众的力量和决定所组成的，在一定的历史条件下，就会发挥结果，汇聚力量，影响方向。当拿破仑希望影响历史，让近卫军停止抢劫，让法国军停止他们的搜刮，结果也是于事无补。事实也证明了即使是拿破仑，理性的决定理性地想要决定历史，也不会比一个二等兵有多大的影响。也就说明了，人对自由意志的感知甚至是一种主观上极度受到时空影响的产物，只有正确了解历史条件认识这种必然，才能够正确参与才能够实现个体的自由</p>
<p>正如微积分一样，从0到1，正是有无穷的1&#x2F;n组成的图像才构成整体的面积，在科学领域这种必然性这种关于无穷小的应用颇广。而在托尔斯泰的笔下，托老认为历史学家总是割裂开去审视离散的点，审视亚历山大，审视老库图佐夫，审视拿破仑，分析他们的错误，而事实上的他们每天面临无数的建议和情况战局，正确的建议被埋没则会被当作历史学家的话柄，但是这样就没有考虑到历史其连贯性</p>
<blockquote>
<p>历史科学在其运动中经常采取越来越小的单位来考察,用这种方法力求接近真理。不过,不管历史科学采取多么小的单位,我们觉得，假设彼此孤立的单位存在,假设某一现象存在着开头,假设个别历史人物的活动可以代表所有人们的肆意行为,这些假设本身就是错误的。<br>任何一个历史结论,批评家不费吹灰之力,就可以使其土崩瓦解，丝毫影响都不会留下,这只消批评家选择一个大的或者小的孤立的单位作为观察的对象,就可以办到了;批评家永远有权利这样做,因为任何历史单位都是可以任意分割的。<br>只有采取无限小的观察单位历史的微分,也就是人的共同倾向,并且运用积分的方法(就是得出这些无限小的总和),我们才有希望了解历史的规律。<br>十九世纪最初的十五年，欧洲出现了数百万人的不寻常的运动。<br>人们抛下他们的日常职业，从欧洲一边跑到另一边,抢劫和互相屠杀，胜利和陷人绝望，几年之间，整个生活的运行改变了,出现一种先高涨后衰退的激烈运动。这运动的起因是什么,它的规律是什么?人的智慧不禁要问。<br>史学家在回答这个问题时,向我们讲述巴黎城内一座建筑物里的几十个人的言行,称这些言行为革命;然后写出拿破仑和某些同情他或故视他的人的详细传记;讲述这些人之中某些人对另一些人的影响,并且说:这就是运动的起因,这就是运动的规律。</p>
</blockquote>
<p>因此始终难以得出答案，却常常陷入对个体的批判中。因此托老并不是一开始直接告诉我们要将连续不断的人民考虑进历史，而是给我们讲了不同阶级的人他们在战争中的故事，他们在战争中的作用。告诉我们<strong>历史不是由英雄创造的，而是由无数平凡生命在无形法则中共同编织的；个人唯有在接纳必然性的同时，投身于具体的生活与爱，才能获得真正的自由</strong>，这观点又何尝不像在题材上截然相反的陀翁呢“爱具体的生活而不是抽象的概念”</p>
<h2 id="童山的安德烈一家"><a href="#童山的安德烈一家" class="headerlink" title="童山的安德烈一家"></a>童山的安德烈一家</h2><p>安德烈一家有安德烈公爵，小公爵夫人，其妹妹玛丽亚公爵小姐，其父亲老安德烈公爵。</p>
<p>安德烈公爵在故事的一开始和其朋友皮埃尔分手后，为了荣誉和虚荣加入了俄法战争，这时的安德烈公爵浮躁，基于建立功勋，在和其家人告别后踏上战争。再几乎接触到死亡后回归家庭，可碰到妻子分娩难产去世，郁郁寡欢数年在童山和父亲妹妹一起生活。</p>
<p>直到遇到娜塔莎，两个人相爱了。可在娜塔莎天真纯洁的被渣男库拉金诱惑后，远在外地的安德烈公爵又转身投入进战争，但是已经改观后的安德烈公爵此时却是由于保护家人和重视的人的生命，为了纯粹的爱国心。</p>
<p>在法军逼近童山时，安德烈公爵给其妹妹写信要求带父亲离开童山前往莫斯科避难。可老安德烈公爵固执的守护自己的土地，守护自己怀念的俄国，死在了故土。在父权体制下，女儿长期遭到父亲的责骂和压迫，在老安德烈公爵的刻薄下，玛丽自卑爱自己的父亲却又恨自己的父亲，老安德烈公爵的爱好像刺刀让玛丽感觉痛又烦躁。在病床前期待着父亲离世的玛丽悉心照料着父亲，因为自己内心的想法又感到别扭的愧疚，直到最后老公爵几乎失去了语言能力才向玛丽道歉，两人才完成真正的理解和彼此和解。但若不是死亡将两人分开，又恐难见到这一面</p>
<p>安德烈公爵在战场上成重伤，又进了娜塔莎家的伤员车内，可最终还是在娜塔莎，儿子和玛丽的注视下离世。他的死亡不是瞬间的，是在逐渐领悟了死亡和上帝的本质后默许了自己的离世，原谅了娜塔莎的背叛，接受了娜塔莎的爱。安德烈公爵终于通过爱和亲情剥离了死亡的恐惧，消解了其自身个人主义的孤岛，实现了俄国民族性格里东正教的上帝的救赎，桥段像加拉哈德历经冒险取得圣杯后看到自己的灵魂的形状，于是上帝带走了加拉哈德。</p>
<p>最后一开始追求名誉的安德烈公爵选择了放手，选择了精神的解脱和救赎。</p>
<h2 id="彼得堡的皮埃尔"><a href="#彼得堡的皮埃尔" class="headerlink" title="彼得堡的皮埃尔"></a>彼得堡的皮埃尔</h2><p>皮埃尔和安德烈公爵恰恰相反，也正如好闺蜜玛丽和娜塔莎所说，这俩人一定是因为个性迥异才成为那么亲密的朋友的。</p>
<p>开始的皮埃尔沉迷酒乐，纵情娱乐。有钱后又加入共济会，思考人生的价值，生命的意义，解放农奴，思考怎么才能做好事但是做的一塌糊涂。但是当皮埃尔自己亲身体会了战场，看到了俄法战士的惨状，才真正消解了其享乐主义的虚无，才真正将抽象的重心转移到了具体。真正的改变是皮埃尔留在了被法国占领的莫斯科，抢救火中的小孩，为了救被法国士兵抢劫的妇女挺身而出甚至被囚禁数月。皮埃尔真正蜕变成为一个实干者。</p>
<p>与娜塔莎最后的婚姻，皮埃尔与其和谐亲密的生活让人欣慰，两个人的互动让人对这两个人改观大变。社交圈认为最傻的皮埃尔和那个天真幼稚的小娜塔莎，把婚姻经营的友好幸福。</p>
<p>再提一嘴娜塔莎，娜塔莎正是这本书中“生命本能”与”具体生活“的体现，正是因为有了娜塔莎前期的被拐，才有中间对自己的赎罪，再到对重伤安德烈公爵的照顾，才最后会有和皮埃尔的幸福成熟的婚姻生活，正是从虚假的资产阶级浪漫中跌落现实，又从从现实和具体找到幸福的关键人物</p>
<p>至此作品落下帷幕，皮埃尔由一个抽象的人类幸福思考者变成了一个真正的幸福实践者。历史从这些抽象的个人英雄和自由主义回归到了群众史观和普世的善恶里。真正的历史由每一个参与其中进程的群众构成，升华了其主题，战争和和平都是人民在不同历史条件下选择的变形，追求和平是要用有爱的体制和所有人而不是单独某个历史人物决定的。</p>
<p>最后，合上书，抽回书签。仿佛依然能看到老安德烈公爵在病床上哽咽着对女儿抱歉，安德烈公爵去世前的超脱，战争中被轻易吞没的生命<strong>彼佳</strong>。战争与和平宏大震撼，但是照见的不是拿破仑和亚历山大气吞山河的个人英雄主义画像，而是历史洪流中形形色色的寻找生活和生命意义的安德烈公爵们和皮埃尔们。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yeluogui.cloud/2025/11/09/%E5%B7%B4%E9%BB%8E%E5%9C%A3%E6%AF%8D%E9%99%A2%E2%80%94%E2%80%94%E6%95%B2%E9%92%9F%E4%BA%BA%E5%92%8C%E4%BB%96%E7%9A%84%E5%9C%A3%E6%AF%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="叶落归">
      <meta itemprop="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="穿过长长的隧道，便是雪国">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/09/%E5%B7%B4%E9%BB%8E%E5%9C%A3%E6%AF%8D%E9%99%A2%E2%80%94%E2%80%94%E6%95%B2%E9%92%9F%E4%BA%BA%E5%92%8C%E4%BB%96%E7%9A%84%E5%9C%A3%E6%AF%8D/" class="post-title-link" itemprop="url">巴黎圣母院——敲钟人和他的圣母</a>
        </h2>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-11-09 00:15:09 / 修改时间：00:57:18" itemprop="dateCreated datePublished" datetime="2025-11-09T00:15:09+08:00">2025-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%87%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">文学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一篇语言瑰丽大气，宏大的戏剧</p>
<p>虽然是小说，但是整体看下来更像是看了一出极大的悲剧。对建筑的介绍好像旁白在默默讲述这个故事，完善14世纪在雨果笔下曾经悲惨的发生过的这个故事的世界</p>
<h1 id="副主教的罪孽与疯狂"><a href="#副主教的罪孽与疯狂" class="headerlink" title="副主教的罪孽与疯狂"></a>副主教的罪孽与疯狂</h1><p>想谈一谈副主教这个人，副主教的品性恶劣，贪图尘世间的享乐陷入疯狂，他显然是巴黎圣母院最复杂也是最可憎的人物，他命令他的敲钟人卡西莫多想让他强取豪夺吉普赛人爱丝梅拉达，听到诗人甘果瓦谈起她甚至会嫉妒愤怒，最后亲手刺穿与爱丝梅拉达幽会的弗比斯的身体又把杀人的罪行栽赃到爱丝梅拉达身上，最后因为爱丝梅拉达不肯委身于他又出卖爱丝梅拉达</p>
<p>他疯狂偏执，为了彻底占有得到爱丝梅拉达，把她逼入绝境让她面临生命与爱情的两难。</p>
<p>他显然是极端的宗教的产物，在这个引他生爱的女人之前，他是一个遵守教规的副主教。他溺爱自己的弟弟，拒绝自己弟弟铺张浪费的消费需求但是又心软给他钱袋子。丑陋的卡西莫多被埃及人扔到巴黎，被所有人视为怪物。副主教克洛德教袍一挥，将他带回圣母院照料。即使是作为仆人，但是敲钟人对他如此的忠诚，难道也不能说明他曾经的本性吗</p>
<p>被教义压抑许久的副主教见到爱丝梅拉达仿佛是见到了最后一根稻草，他对她的占有欲达到了疯狂。有如陀翁笔下被娜斯塔霞折磨内心狂热最后杀害了她的罗果仁。区别在于副主教是一个坏到根子里为了得到爱丝梅拉斯而施以暴行而做出许许多多极端恶事最后又毫不知悔改之人</p>
<p>但是犯下罪行即是不可饶恕，但是诚然</p>
<p>副主教的恶是宗教对人的异化，是极端的禁欲造成的恶果。一辈子遵守教条行善的他造成如此恶果，只能说明他的人性和欲望在教条的扭曲下变成了极端的恶</p>
<h1 id="卡西莫多和英俊的骑士"><a href="#卡西莫多和英俊的骑士" class="headerlink" title="卡西莫多和英俊的骑士"></a>卡西莫多和英俊的骑士</h1><p>我更希望把卡西莫多和弗比斯放在一起讲</p>
<p>书的序言是将副主教和卡西莫多放一起讲来说美善对比了，可我始终认为副主教更为特殊一些</p>
<p>而丑陋到了极致的卡西莫多和英俊潇洒的弗比斯更能体现出善恶对比</p>
<p>埃及女孩爱丝梅拉达纯真善良，为了拯救诗人克洛德，她不惜和他假结婚。</p>
<p>为了和弗比斯的爱，她甘愿自己卑微到骨子里。</p>
<p>当敲钟人受了刑罚在炎炎灼阳下求口水却只能得到群众的唾弃时，她愿意拿出泉水相报。我一度觉得这就是巴黎圣母院和敲钟人的圣母</p>
<p>敲钟人为了报恩在爱丝梅拉达的处刑台下救了他，而弗比斯隐瞒自己根本没有死的事实，新鲜感褪去后眼睁睁看着爱丝梅拉达因为杀害了自己的罪被判处绞刑</p>
<p>敲钟人善良处处体谅者“圣母“的心思，怕她嫌自己丑会生出无法遏制的生理性厌恶（事实上爱丝梅拉达也在克制这份厌恶）。而弗比斯在面对敲钟人“去看一看她吧”的请求时却只是把敲钟人一脚踢翻。为了不使爱丝梅拉达伤心甚至编造出没有等到的谎言引得爱丝梅拉达发怒</p>
<p>敲钟人朴素的善和弗比斯自私自利的丑恶形成的善恶对比强烈，正如敲钟人所说碎瓶虽美花却枯萎，完瓶虽丑花枝满满</p>
<p>最后爱丝梅拉达因为对弗比斯不切实际自欺欺人的爱丢掉了性命，徒让母女相遇变成更大的悲剧（此处更是一处非常戏剧性的表达，因为种族而极端厌恶爱丝梅拉达的隐修女，在得知其是自己女儿后的如火球燃烧一样极大的兴奋，却又在下一幕女儿被带走后浇得熄灭）</p>
<p>爱丝梅拉达直到最后也没有真正的接受丑陋敲钟人，但是却能接受英俊弗拉达的虚伪，甚至在看到他和女士在一起看她的绞刑时也为他辩解只是友人或者妹妹。这是全社会的偏见，敲钟人的丑陋在书外何尝不是各种社会因素的堆砌，人们习惯性对那些庸俗的美权力等献媚，有时何尝不是对敲钟人丑陋的鄙视和愚蠢的社会性偏见呢</p>
<p>这本书诸多的戏剧化的对比，让这本书的情节拥有生命，一切归为虚无，所有的善都没有得到好的结局。而恶人们结婚，统治继续当副主教，巴黎圣母院是一篇极出色的悲剧，他的伟大正是把剧和小说融合在一起。使每一个读者都能感受到深深的无力悲伤，就像秋天之末，只能感叹春夏走，冬会来</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yeluogui.cloud/2025/10/29/%E7%BB%BF%E6%88%BF%E5%AD%90%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="叶落归">
      <meta itemprop="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="穿过长长的隧道，便是雪国">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/29/%E7%BB%BF%E6%88%BF%E5%AD%90%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/" class="post-title-link" itemprop="url">绿房子——迷幻的土地和人儿们</a>
        </h2>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-29 12:04:27 / 修改时间：12:24:39" itemprop="dateCreated datePublished" datetime="2025-10-29T12:04:27+08:00">2025-10-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%87%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">文学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《绿房子》人物关系表"><a href="#《绿房子》人物关系表" class="headerlink" title="《绿房子》人物关系表"></a>《绿房子》人物关系表</h1><table>
<thead>
<tr>
<th>角色姓名</th>
<th>身份&#x2F;职业</th>
<th>主要关系</th>
<th>关系说明</th>
</tr>
</thead>
<tbody><tr>
<td>安塞尔莫</td>
<td>老琴师&#x2F;绿房子创始人</td>
<td>安东尼娅、琼卡</td>
<td>绿房子的建造者</td>
</tr>
<tr>
<td>安东尼娅</td>
<td>盲女</td>
<td>安塞尔莫、加西亚神父</td>
<td>盲女，被老琴师追求爱慕</td>
</tr>
<tr>
<td>琼卡</td>
<td>妓院老板娘</td>
<td>安塞尔莫、拉丽塔</td>
<td>接手经营绿房子</td>
</tr>
<tr>
<td>鲍尼法西亚</td>
<td>修女&#x2F;士兵妻子</td>
<td>利图马</td>
<td>曾为修女，后嫁士兵利图马</td>
</tr>
<tr>
<td>利图马</td>
<td>士兵</td>
<td>鲍尼法西亚</td>
<td>与鲍尼法西亚结婚，性格粗犷</td>
</tr>
<tr>
<td>伏屋</td>
<td>橡胶商人&#x2F;逃犯</td>
<td>拉丽塔、阿基里诺</td>
<td>带领拉丽塔逃亡，性格暴戾</td>
</tr>
<tr>
<td>拉丽塔</td>
<td>富西亚的情人</td>
<td>伏屋、阿基里诺</td>
<td>随伏屋逃亡，后与领水员私奔</td>
</tr>
<tr>
<td>阿基里诺</td>
<td>船夫&#x2F;向导</td>
<td>伏屋、拉丽塔</td>
<td>帮助伏屋和拉丽塔在亚马逊河流域逃亡</td>
</tr>
<tr>
<td>加西亚神父</td>
<td>神父</td>
<td>安东尼娅</td>
<td>收养安东尼娅并助其成为修女</td>
</tr>
<tr>
<td>胡姆</td>
<td>土著首领</td>
<td>富西亚、土著村民</td>
<td>领导土著反抗橡胶商人的剥削</td>
</tr>
</tbody></table>
<p>有点命中注定的宿命的故事，最后一切都有了一个好的归宿</p>
<p>但是一切又要从最开始讲起，老琴师建立了第一家绿房子。作为一切的开端他爱上了盲女与她私奔把她藏起来，不明所以的神父带着人气势汹汹的替天行道烧了第一家绿房子。故事就从这里慢慢展开</p>
<p>此时的伏屋结识了送水员阿基里诺，在往后的人生中他或许会无限的感激这位好朋友。这也是略萨行文的温柔之处吧，如此暴戾残酷的伏屋在弥留之际却真正的信任了阿基里诺，善良的阿基里诺也把伏屋视为了朋友。在书中最后一次会面，阿基里诺想的是“明年我一定还会来的，伏屋，你不要难过”，给一个一生雄心勃勃的野心家划上了一个孤独苍老渴望陪伴的句号。</p>
<p>伏屋的妻子作为连接他们的桥梁，和领水员私奔后，又将鲍尼法西娅介绍给了警长。鲍尼法西娅作为一个土著人的女儿从小就被抢到修道院，美其名曰接受文明的教化，在因为一时的善心而放走了二十位土著女孩后被赶出修道院，被领水员夫妇收养。</p>
<p>在鲍尼法西娅和警长结婚后不久，警长就因为在绿房子闹事害了人命被抓走，继而被何塞里诺和他的朋友们糟蹋还送到了绿房子做妓女。</p>
<p>一切仿佛都在朝着最坏的方向发展，鲍尼法西娅的故事最后变成了啼笑皆非的悲剧，她成为了一群二流子的情妇自诩为婊子又用当妓女的钱养着刚出狱还要打他的警长。</p>
<p>老琴师一手创造的绿房子不仅仅只是妓院，他和现代语境下那种泯灭自由的妓院似乎有所不同，当然也不能掩盖其剥削无产阶级性自由本质。但是他仍然给底层人民多了一种改善生活的选择，给这座荒废了生活的城市带来了音乐和艺术。在被神父带人火烧了绿房子后，你是痛苦的吧，但是更痛苦的是失去了所爱是失去了托尼亚。</p>
<p>最后才是略萨的温柔，老琴师去世，神父被说服为他守灵主持弥撒，最后达成和解。</p>
<p>看完这本书，其实我很难说得清我感受到了什么或者说想到了什么，但是很喜欢这个故事，给了拉丽塔一个温柔的结局子孙满堂，给了伏屋一个悲惨但是却又隐隐有所期待的结局，又给了老琴师一个善终最后散发人性光辉的结局。只是可怜的土著鲍尼法西娅被强行剥离出自己的族群和文化最后又堕落沦为二流子们的玩物和经济来源。</p>
<p>虽然逊于酒吧长谈，但也算是略萨很值得一读的作品！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yeluogui.cloud/2025/09/19/%E6%98%AF%E7%99%BD%E7%97%B4%E4%B9%9F%E6%98%AF%E5%9F%BA%E7%9D%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="叶落归">
      <meta itemprop="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="穿过长长的隧道，便是雪国">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/19/%E6%98%AF%E7%99%BD%E7%97%B4%E4%B9%9F%E6%98%AF%E5%9F%BA%E7%9D%A3/" class="post-title-link" itemprop="url">是白痴也是基督</a>
        </h2>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-19 12:40:01 / 修改时间：13:08:37" itemprop="dateCreated datePublished" datetime="2025-09-19T12:40:01+08:00">2025-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%87%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">文学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本书依然是陀思妥耶夫斯基经典的复调，从这本书里也能看到许多他其他作品的影子。</p>
<p>伊波利特有地下室人的特质，神经质渴望被认可，帮助布尔多夫斯基造谣诽谤公爵时是一个顶坏的人，但是后面又能从他的自述中了解到他对生命将逝的恐惧，行将就木想要完成人生的夙愿，他的可悲甚至是生命剩余的倒计时不足以他完成一个需要长期投入的善行中。</p>
<p>这些特殊而又矛盾的人们，带着心中的嫉妒仇恨还有美德一次次的用自己的观点交锋</p>
<p>主角正是这些时常善良而又时常被内心折磨的人们中最置身事外但是又察颜悦色，完全带着基督的博爱宽容着一切的人。公爵的爱情正是说明了这一点。</p>
<h2 id="娜斯塔霞的逃婚"><a href="#娜斯塔霞的逃婚" class="headerlink" title="娜斯塔霞的逃婚"></a>娜斯塔霞的逃婚</h2><p>梅诗金公爵对她的感情究竟是怎么样呢？我看了一个博主的观点，我们现在爱情要求纯粹无暇，于是我们的感情被说的很简单，纯爱柏拉图…但是对于公爵来说，爱可以是复杂的，公爵对娜斯塔霞的爱绝不仅仅是单纯的怜悯和同情，同时包含着借由博爱而衍生出来的怜爱。公爵潜在的善意激发了这份爱，对这位可怜女性的爱更多的是出于善意</p>
<p>于是娜斯塔霞逃婚了，很多人说娜斯塔霞不想毁掉公爵的好名声和人生，才三番五次地逃离公爵，这份愧疚感和爱意包裹了她。她甚至为了救赎选择帮公爵找一个未婚妻，却又为了尊严和阿格拉雅争执起来。所以我觉得娜斯塔霞的人格底色是尊严，她不仅仅是为了公爵，更是为了她自己的尊严。</p>
<p>这也牵扯出了本书的一个核心，基督的爱究竟有什么现实意义吗。陀老一辈子是个坚定的基督徒，他相信博爱，但是在他的书里这种博爱被反复地抨击敲打乃至颠覆。马拉卡佐夫兄弟中的伊万以宗教大法官之文反对了基督的博爱是在毁掉人们的平衡。</p>
<p>那公爵一个没有基督之力却有基督之爱的人呢，天真幼稚，虽然会看人脸色给人劝慰但归根结底他不懂真实的人心。他开始怀疑俄国的社交界腐朽但是看到他们聚在一起却又真的以为他们高尚高雅善良，当他表现出他的赞美出现的自然也只是丑陋之人的嗤笑</p>
<p>因此善良变成白痴，天真变成愚妄。</p>
<p>这种基督式的爱不加节制，公爵骑士一样的善良虽然有所察觉，但是搞砸了一切，促使老将军的死亡，无法救赎伊波利特，伤害了所有人包括娜斯塔霞的自尊和灵魂，促使她的逃婚</p>
<p>我甚至觉得娜斯塔霞最后的结局是自杀，因此公爵看到罗果仁才没有多说什么，只是看见就已经心领神会</p>
<h2 id="具体的爱"><a href="#具体的爱" class="headerlink" title="具体的爱"></a>具体的爱</h2><p>地下室手记告诉我们要爱具体的人不要爱具体的概念，巧合的是他们的女主人公都叫娜斯塔霞。没错公爵以世俗的心爱上的就是阿格拉雅，他们彼此相爱，但是公爵的博爱一直引诱促使着自己去拯救娜斯塔霞</p>
<p>正如叶甫盖尼所说</p>
<blockquote>
<p>不，公爵，她不会谅解的！阿格拉雅：伊万诺夫娜对您的爱是一个女人的爱，她是一个有血有肉的人，而不是··抽象的灵魂</p>
</blockquote>
<p>公爵对娜斯塔霞的爱是抽象的，以怜悯为主的。对阿格拉雅的爱是真实的，所以修罗场对峙中，公爵几乎是毫不犹豫地就去追阿格拉雅</p>
<p>可惜具体的真正的爱需要偏爱，而不需要一个会爱所有人的基督</p>
<h2 id="基督在人间"><a href="#基督在人间" class="headerlink" title="基督在人间"></a>基督在人间</h2><p>于是人间的基督失败了，所有人即使讨厌他的人也爱他尊敬他，可他依然是白痴。</p>
<p>他的天真和博爱搞砸了一切，他以为他能像在瑞典一样救赎其他人，但是这种骑士精神在俄国就只是“白痴”，正如叶班钦娜将军夫人所说这一切都是一场幻梦。公爵又变成了真正的白痴，阿格拉雅为了追求爱的幻影出走，罗果仁杀人被流放，娜斯塔霞被杀死。一切都是因为公爵不加筛选的爱。伤害了娜斯塔霞的自尊心，激发了罗果仁的嫉妒，也促成了阿格拉雅的疯狂</p>
<blockquote>
<p><em>“昏头昏脑的蠢事做得够了，该清醒过来了。所有这一切，国外的全部生活，你们的整个欧洲——通通是一场空幻，我们在国外也都是一片空幻…记得我的话吧，到时候您自会明白！”</em></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yeluogui.cloud/2025/08/31/%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%E4%B8%8E%E4%BD%8D%E6%8B%93%E5%B1%95%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="叶落归">
      <meta itemprop="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="穿过长长的隧道，便是雪国">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/31/%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%E4%B8%8E%E4%BD%8D%E6%8B%93%E5%B1%95%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">多模块交叉编址与位拓展的区别💻</a>
        </h2>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-31 18:24:54" itemprop="dateCreated datePublished" datetime="2025-08-31T18:24:54+08:00">2025-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-21 23:44:38" itemprop="dateModified" datetime="2025-12-21T23:44:38+08:00">2025-12-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>549</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://s3.bmp.ovh/imgs/2025/08/19/dd7abadf3c59a52e.gif"></p>
<p>个人理解:</p>
<p>两者虽然都是用芯片组成新的内存条，但是位拓展是逻辑上让这些芯片属于一个新的内存条，拓展了每个存储单元的大小。</p>
<p>而多体交叉编址并未改变其存储单元大小，只是让数据以他的规则进行排序</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/31/8c78993f463a8702.png"></p>
<p>以本题为例，已经确定为按字节编址，故每个存储单元位数都为一字节，自然不能使用位拓展将存储单元的位数扩大</p>
<p>则必须使用多模块交叉编址</p>
<p>多模块交叉编址的分类</p>
<h2 id="顺序编址（高位交叉）"><a href="#顺序编址（高位交叉）" class="headerlink" title="顺序编址（高位交叉）"></a>顺序编址（高位交叉）</h2><p>这种情形下，我们按地址的前几位进行存储数据，如果有4个芯片，则前两位作为区分所在模块的位置如<strong>01</strong>000000——<strong>01</strong>1111111，将数据顺序存储起来。</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/31/27dcf2ba27269f94.png"></p>
<p>但是这样无法让他们并行启动，假如总线周期是1，而一个存期周期是4，那么当总线占用完传完数据后只能等待3才能继续下一个存储单元的使用</p>
<h2 id="交叉编址（低位交叉）"><a href="#交叉编址（低位交叉）" class="headerlink" title="交叉编址（低位交叉）"></a>交叉编址（低位交叉）</h2><p>交叉编址则是以后几位为标准进行存储，这样就能把顺序数据均匀的分布在四个芯片上了</p>
<p>如何区分这四个是轮流启动还是一起启动呢？要看总线宽度和DRAM的位数，如果4个DRAM的位数合在一起是32位，而总线宽度也是32，则可以一起启动，四个一起传输到总线上</p>
<p>如果一个DRAM的位数和总线宽度一致，那么每次总线只能传输一个存储单元，则需要流水线的方式来进行传输。模块个数也就是大于等于T/r，否则总线周期已经结束，下一个芯片的存取周期还没结束只能干等着</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/31/1788f6bd5ecc69ac.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yeluogui.cloud/2025/08/29/%E8%8A%92%E6%9E%9C%E6%85%95%E6%96%AF%E5%B8%83%E4%B8%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="叶落归">
      <meta itemprop="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="穿过长长的隧道，便是雪国">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/29/%E8%8A%92%E6%9E%9C%E6%85%95%E6%96%AF%E5%B8%83%E4%B8%81/" class="post-title-link" itemprop="url">芒果慕斯布丁🍮</a>
        </h2>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-29 23:34:56 / 修改时间：23:34:44" itemprop="dateCreated datePublished" datetime="2025-08-29T23:34:56+08:00">2025-08-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%83%98%E7%84%99/" itemprop="url" rel="index"><span itemprop="name">烘焙</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>
            <div class="post-description">慕斯甜香，布丁清凉，奶油醇厚，香气四溢的芒果蛋糕在这个时节正和一杯饮料是绝配</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>炫耀一下我新做的布丁蛋糕！</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/29/df76d2e9926a0f32.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yeluogui.cloud/2025/08/18/%E5%8D%A1%E6%8B%89%E9%A9%AC%E4%BD%90%E5%A4%AB%E5%85%84%E5%BC%9F%E2%80%94%E2%80%94%E5%96%84%E6%81%B6%E8%BD%AC%E5%8F%98%E4%B8%8E%E4%B8%8A%E5%B8%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="叶落归">
      <meta itemprop="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="穿过长长的隧道，便是雪国">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/18/%E5%8D%A1%E6%8B%89%E9%A9%AC%E4%BD%90%E5%A4%AB%E5%85%84%E5%BC%9F%E2%80%94%E2%80%94%E5%96%84%E6%81%B6%E8%BD%AC%E5%8F%98%E4%B8%8E%E4%B8%8A%E5%B8%9D/" class="post-title-link" itemprop="url">卡拉马佐夫兄弟——善恶转变与上帝</a>
        </h2>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-18 12:35:56 / 修改时间：13:17:06" itemprop="dateCreated datePublished" datetime="2025-08-18T12:35:56+08:00">2025-08-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%87%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">文学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>陀翁的最后一舞《卡拉马佐夫兄弟》并未写完，其被视为文学史上的一颗明珠和高峰</p>
<p>老卡拉马佐夫和卡拉马佐夫四兄弟几乎代表了陀翁本人的四个课题</p>
<p>也就是译者荣如德说的四个R</p>
<p>心灵隐秘(Revelation of Man’s secret heart)、革命(Revolution)、俄罗斯(Russia)和宗教(Religion)</p>
<h2 id="Revelation-of-Man’s-secret-heart"><a href="#Revelation-of-Man’s-secret-heart" class="headerlink" title="Revelation of Man’s secret heart"></a>Revelation of Man’s secret heart</h2><p>卡拉马佐夫父子之间的关系可以说是畸形，老卡拉马佐夫为人卑鄙丑陋，几乎极全人类的劣根性为一身，荒淫无度唯利是图的小人模样透过纸笔将其扭曲的哲学思维表现出来。但是老卡拉马佐夫为何却偏爱阿辽沙这个小儿子，阿辽沙并非逢场作戏假意迎合父亲，而是的确怀抱着博爱的精神去看待自己这荒唐的一家子。老卡拉马佐夫对阿辽沙表现出来的微不足道的爱实际上是这个人物正面的另一面卑微胆小渴望得到一部分认可，但是他的丑陋就像译者所说相当一部分就是取自陀翁的老农奴主父亲</p>
<p>再看我们的三位卡拉马佐夫兄弟，老大米剑卡是陀思妥耶夫斯基当兵时真实的写照，无法控制情绪又有相当高的自尊心，他一方面为了与父亲争夺情妇能愤慨地到处宣扬要杀了父亲，为了情妇抛弃未婚妻，而一方面又对自身崇高的爱情保持敬重，对自己用未婚妻的钱去背叛未婚妻感受到前所未有的痛苦。米嘉其人我觉得正是卡拉马佐夫兄弟这部作品的精髓所在，他身为人的两面性，他的善恶在不断的拉扯转变。他为了自身的爱选择了卑鄙的手段。但却又在几乎决定要杀掉父亲的时候转身离去。伊万作为这部书理性的代表，他反对上帝，反对基督，他在的科学带领下的诞生的新哲学深深压迫着灵魂。《宗教大法官》正是他认为的现世战胜了身后生命，恶魔战胜了基督在脑内形成的长诗，他的理性带着他走过10000的4次方公里，所以他感到疯狂，但是又在最后站出来为自己的哥哥作证哪怕自己会被贴上怂恿作案的标签。阿辽沙和佐西马长老几乎代表了宗教中的善，两人都相信世上的爱，对世界万物充满博爱。而私生子老四从小受尽白眼没有兄弟们的继承权，只能做自己父亲的奴才被一个疯女人生下来，他表面唯唯诺诺但是内心狡诈阴险，最后狡诈阴险的自杀却因留下不要怪任何人为终</p>
<h2 id="Religion"><a href="#Religion" class="headerlink" title="Religion"></a>Religion</h2><p>卡拉马佐夫兄弟本书讨论的核心即为善恶和宗教。上帝与恶魔对俄罗斯人民的捉弄，当恶魔占领米剑卡的内心时，他为了爱情策划铤而走险敲碎老子的脑壳，但是当真正闯进了其父的房间时，他却犹豫了逃走了。他的恶念和善念时常交叉，脑子发热让他做出诸多可怕的事拿一个生活艰难的上尉出气，花掉了未婚妻给的钱只为了和情妇狂欢。作为这本书中善恶两面最明显的存在，他显然拥有着野蛮主导的一面，他爱的彻底又狂热的可怕，善恶在他心中没有定论，因此善良的天使和丑恶的魔鬼时常接管他的内心，但是又像辩护律师所讲，他绝不可能犯下杀人的案子尤其是杀父即使这称不上是一个父亲，他其实宽容只是野蛮，他其实温情只是焦躁，他其实善良只是凶恶。</p>
<p>老卡拉马佐夫认识到的是生命的虚无，他不像伊万一样否认上帝又在否认了身后生命的情况下决定即使没有身后生命人也可以行善，他成为了活脱脱的虚无主义者，他像动漫里的瑞克一样，纵情享乐，逃避一切社会带给他的责任，亲情和羁绊，失去一切道德。伊万在想的就是失去了基督对来世的承诺，难道人就不会像父亲一样“法无禁止皆可为”吗，难道就不会烧杀淫掠吗？但是依我所想，信仰即是人类社会存续和发展的基础，无论信仰什么，广义上我们信仰的是社会规则，共同的文化和文字。陀翁借伊万和阿辽沙讨论之口表达的正是自己的担忧，失去了基督的博爱，人类会不会退化成动物，人会不会觉得生命像人文主义者所说的一样是一场旅程，因此再也不在意善恶再也不考虑德行。可是人类社会的信仰并非一定出自于宗教和基督，伊万内心对杀死上帝存在的挣扎正体现在了恶魔对他说的“不相信身后生命的人死后被惩罚走一万的四次方公里”，我们社会存在的信仰可是却并非是上帝，我们依然存在真理，我们信仰的真理虽然是人造的并非像杜撰的上帝一样好像来自于神创造的自然的。而人创造的顺应社会发展，人们和谐共处的原则和社会规则也正是指引人向上的工具</p>
<p>陀翁处在一个基督将死的世界，伊万正是这个害怕但是却以理性为指导最后几乎要疯了的人，但是阿辽沙最后也说即使卡嘉觉得他有事但是他其实最后一定会康复，伊万最后会代替陀翁去一个新时代见证新的思想，上帝虽死但是真理复苏，崇拜科学和真理的时代唤醒新的伦理观。阿辽沙最后和郭立亚送走了伊柳沙，曾经欺侮嘲弄伊柳沙的孩子们此时为善良流出眼泪，为人类最伟大的精神动容。未来的社会主义者郭立亚对他崇拜的基督徒阿辽沙表达了自己一定会追求真理，阿辽沙对孩子们说不管他们以后想去做什么一定要记住善良的今天，记住为伊柳沙流泪的今天，当有一天要行凶作恶的时候回忆起这一天一定会赶走心中的恶魔。仿佛太阳初升一般，阿辽沙和郭立亚两个人定然一定会为今天的善追求真正的真理，不再是基督而是即将到来的全人类的更崇高的理想</p>
<h2 id="Russia"><a href="#Russia" class="headerlink" title="Russia"></a>Russia</h2><p>作为一个民族倾向很明显的作家，陀翁显然是一个俄罗斯的民族主义作家，他描写了这个民族的底色，像米剑卡一样冲动敢爱敢恨，像伊万一样理性自我折磨，像阿辽沙一样善良博爱，又像老卡拉马佐夫一样陷入虚无。这些都是Russia，作者以自己的人设阅历写尽自己所知的俄罗斯和对俄罗斯母亲的爱。这些特性显得荒诞不经，但是却</p>
<blockquote>
<p><em>世上太需要荒唐了。这世界就是靠荒唐支撑起来的，要是没有荒唐，世界只是一潭死水</em></p>
<p><em>如果得不到肯定的解答，也就永远得不到否定的解答，您知道自己的心有这一特点，而这正是您的心的全部痛苦所在。</em></p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/17/05703f0abcb6ebce.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yeluogui.cloud/2025/08/16/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="叶落归">
      <meta itemprop="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="穿过长长的隧道，便是雪国">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/16/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4/" class="post-title-link" itemprop="url">平衡二叉树的插入与删除</a>
        </h2>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-16 16:08:32" itemprop="dateCreated datePublished" datetime="2025-08-16T16:08:32+08:00">2025-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-21 23:43:53" itemprop="dateModified" datetime="2025-12-21T23:43:53+08:00">2025-12-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>822</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://s3.bmp.ovh/imgs/2025/08/17/0f60a2174ae3e1fa.jpg">最烦的一集，还好学会了，把经验写出来</p>
<h1 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h1><h2 id="LL-RR情况"><a href="#LL-RR情况" class="headerlink" title="LL&RR情况"></a>LL&amp;RR情况</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/17/00af9cefb4d1be99.png" alt="LL平衡旋转"></p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/17/a1c8d026ce5bce57.png" alt="RR平衡旋转"></p>
<p>不管是LL还是RR，都先找到最先失调的根节点A**（也就是他的左右子树高度差大于2）**</p>
<p>在找到A较高的那棵子树的父亲结点B，然后B朝着A的方向旋转</p>
<p>以LL为例子，右旋，并且将自己的右树给A（向哪里旋转，就将被旋转的结点的 旋转方向的树给出去）</p>
<h2 id="LR-RL情况"><a href="#LR-RL情况" class="headerlink" title="LR&RL情况"></a>LR&amp;RL情况</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/17/4aca5904a1a43d00.png" alt="LR平衡旋转"></p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/17/18b3007bbb7bd2d6.png" alt="RL平衡旋转"></p>
<p>若将新的结点插到最先失调结点的左孩子的右树或者右孩子的左树，则使用RL或者LR</p>
<p>以LR为例</p>
<p>我们按之前的方法找到了B，也就是失调结点A的比较深的树的父亲B</p>
<p>再把新结点的父亲且是B的孩子，也就是B的树深最高的树的父节点C</p>
<p>此时将C和B替换，让C先左旋（因为是向左旋转，将CL给B），然后再右旋（因为是向右旋转，此时把CR给A）</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/17/66637fafb0ba0956.jpg"></p>
<h1 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h1><p><img src="https://s3.bmp.ovh/imgs/2025/08/17/5b193c4a5a360768.png"></p>
<p>王道课上的删除步骤</p>
<p>这里不讨论调整完二次失衡的情况，只需要根据以下步骤再来一次即可</p>
<h2 id="LL-RR情况-1"><a href="#LL-RR情况-1" class="headerlink" title="LL&RR情况"></a>LL&amp;RR情况</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/17/06e1bbc4c485c2d2.png"></p>
<p>以此图为例，在其中75就是第一个失调的结点A</p>
<p>然后找到他最高子树的父节点B也就是80，因为是A的右节点B的右树较高破坏了平衡，所以使用RR，直接令80旋转到75的位置并给75一个77的右节点</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/17/084728c3f7def865.png"></p>
<h2 id="LR-RL情况-1"><a href="#LR-RL情况-1" class="headerlink" title="LR&RL情况"></a>LR&amp;RL情况</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/17/366b42791725dd19.png"></p>
<p>以此图为例，首先找到第一个失衡的A也就是44，他最高的树的父节点是78也就是B</p>
<p>我们这里找到是B的左树过高导致失调，因此是LR</p>
<p>将50右旋送到78的位置并给78一个62的右节点，再左旋到44的位置并给48的右节点</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/17/0f2ded20fb24c30a.png"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>是自己总结的规律，原本的太难记了</p>
<p>我的规律插入和删除是一样的：</p>
<ol>
<li>找到失调的结点A（左右树高第一次大于2）</li>
<li>找A的两棵子树中谁更高，将其A的这个儿子当作B</li>
<li>如果这个B是A的左孩子，但是是B的左树较高，<strong>就将B旋到A的位置，并且将B靠近A的子树（右旋送右，左旋送左）送给A作为子树（旋转的底层逻辑：把自己的靠着被选结点的子树送一个给被旋到的结点）</strong></li>
<li>如果这个B是A的左孩子，但是是B的右树较高，则将B的右树的儿子设为C（这里就是LR了）<br>先让C旋到B的位置，再旋转到A的位置</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/17/128fa305fa31136f.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yeluogui.cloud/2025/08/14/408%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="叶落归">
      <meta itemprop="description" content="”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="穿过长长的隧道，便是雪国">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/14/408%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%B3%95/" class="post-title-link" itemprop="url">408算法题解法</a>
        </h2>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-14 23:05:25" itemprop="dateCreated datePublished" datetime="2025-08-14T23:05:25+08:00">2025-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-21 23:43:15" itemprop="dateModified" datetime="2025-12-21T23:43:15+08:00">2025-12-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文整合自王道和里昂学长的PPT（无盈利侵权必删），是完整的408代码大题解题方案，整合好的pdf文档可以联系我获取</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/14/b31df34148c3f86a.png" alt="王道强化课快速排序代码"></p>
<p>快速排序算法以huafen()函数为核心</p>
<h3 id="如何划分？"><a href="#如何划分？" class="headerlink" title="如何划分？"></a>如何划分？</h3><p><em><strong>第一趟</strong></em></p>
<p>首先将左指针L对应的数组元素设为mid值，我们之后要将mid值和其他值对比然后找到mid值该在的位置</p>
<p>先从R向前寻找第一个小于mid的值（如果没有R- -一直找），如果有，就把他和目前存着mid值的A[L]互换位置</p>
<p>再从L向后寻找第一个大于mid的值（如果没有L++一直找），如果有，就把上一步的A[R]换过来</p>
<p><em><strong>第二趟</strong></em></p>
<p>上一趟完成了第一次交换，把小于mid的换到了右边，而把大于mid的换到了左边</p>
<p>第二趟又在新的R找到了小于mid的元素，放在之前发现的左边覆盖，以此类推</p>
<p><em><strong>最后一趟</strong></em></p>
<p><strong>当最后一趟开始时，若是L++导致L==R则</strong></p>
<p>A[L]换上了右边更小一点的元素。</p>
<p>而下一步L++，已不满足L&lt;R的条件。而这一步的L就是上一步的R(<strong>L==R</strong>)，A[R]的值已经迁移到了其左边。</p>
<p>因此设A[L]=mid，就把两者很好的拆开了</p>
<p><strong>当最后一趟开始时，若是R- -导致L==R则</strong></p>
<p>也就是上一趟将**大于mid的A[L]**的值放到右边时，将较大的值换到了A[R]中。</p>
<p>此时R- -到<strong>R==L</strong>，因此此时A[L]中的存储的是已经是到了还没有**R–**时的右边。</p>
<p>因此A[L]=mid，即可拆开</p>
<h3 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h3><p>因此在快排中调用这段代码</p>
<p><strong>先将A中的LR成以mid为中间的两段，左边小于mid，右边大于mid</strong></p>
<p>我们的划分传来的是mid的位置，因此要想把整个数组排序好，只需要排好左右一直调用。</p>
<p>将数组的最左边L和mid的前一个位置进行划分，穷举下去即可解决</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Qsort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> L, <span class="type">int</span> R)</span> {</span><br><span class="line">    <span class="keyword">if</span>(L &gt; R) <span class="keyword">return</span>; <span class="comment">//递归终止</span></span><br><span class="line">    <span class="type">int</span> M = huafen(A, L, R);</span><br><span class="line">    Qsort(A, L, M<span class="number">-1</span>); <span class="comment">//左半部分快排</span></span><br><span class="line">    Qsort(A, M+<span class="number">1</span>, R); <span class="comment">//右半部分快排</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hualen</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> L, <span class="type">int</span> R)</span> {</span><br><span class="line">    <span class="type">int</span> mid = A[L];</span><br><span class="line">    <span class="keyword">while</span>(L &lt; R) {</span><br><span class="line">        <span class="keyword">while</span>(A[R] &gt;= mid &amp;&amp; L &lt; R) R--;<span class="comment">//等于号能保证其相对位置不变，稳定性这一块</span></span><br><span class="line">        A[L] = A[R];</span><br><span class="line">        <span class="keyword">while</span>(A[L] &lt;= mid &amp;&amp; L &lt; R) L++;</span><br><span class="line">        A[R] = A[L];</span><br><span class="line">    }</span><br><span class="line">    A[L] = mid;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="划分函数的妙用"><a href="#划分函数的妙用" class="headerlink" title="划分函数的妙用"></a>划分函数的妙用</h2><p>求数组中第k小元素的方法</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/14/717cb264da519ef4.png" alt="王道强化课huafen函数"></p>
<p>按理说我们只需要快速排序好，再直接利用数组的随机查找特性找到A[k-1]就可以</p>
<p>但是huafen函数可以直接找到某个元素的具体位置，我们可以直接用M接收huafen函数传来的此时的位置</p>
<p>若这个位置比已知位置小，则k-1在M前面，则设L=M+1继续试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="type">int</span> L = <span class="number">0</span>, R = n - <span class="number">1</span>, M = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        M = huafor(A, L, R);</span><br><span class="line">        <span class="keyword">if</span>(M == k - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(M &gt; k - <span class="number">1</span>) R = M - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(M &lt; k - <span class="number">1</span>) L = M + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> A[k<span class="number">-1</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序用于两个数组排到一个数组里的排序中</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/24/6d87169ec4d005c4.png" alt="归并排序王道强化课"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> N, <span class="type">int</span> B[], <span class="type">int</span> M, <span class="type">int</span> C[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; N &amp;&amp; j &lt; M) {</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= B[j])</span><br><span class="line">            C[k++] = A[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            C[k++] = B[j++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (i &lt; N)</span><br><span class="line">        C[k++] = A[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; M)</span><br><span class="line">        C[k++] = B[j++];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="查找-删除"><a href="#查找-删除" class="headerlink" title="查找+删除"></a>查找+删除</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/24/9851b742dd4fa632.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除值为 x 的结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deletX</span><span class="params">(LinkList L, <span class="type">int</span> x)</span> {</span><br><span class="line">    LNode *pre = L; <span class="comment">//pre指向p的前驱结点</span></span><br><span class="line">    LNode *p = pre-&gt;next; <span class="comment">//p指向下一个要处理的结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">//对当前结点p进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x) {</span><br><span class="line">            LNode *q = p; <span class="comment">//删除并释放值为x的结点</span></span><br><span class="line">            p = p-&gt;next; <span class="comment">//p指向后一个结点</span></span><br><span class="line">            pre-&gt;next = p; <span class="comment">//修改前驱结点的next指针</span></span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            pre = p; <span class="comment">// pre、p 后移</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="查找-插入"><a href="#查找-插入" class="headerlink" title="查找+插入"></a>查找+插入</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/24/c58403e27d9f530a.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在递增有序链表中插入值为 x 的信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertX</span><span class="params">(LinkList L, <span class="type">int</span> x)</span> {</span><br><span class="line">    LNode *pre = L; <span class="comment">//pre指向p的前驱结点</span></span><br><span class="line">    LNode *p = pre-&gt;next; <span class="comment">//p指向下一个要处理的结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">//对当前结点p进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &gt; x) {</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//应插入到p的前面</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            pre = p; <span class="comment">// pre, p 后移</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    LNode *q = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    q-&gt;data = x;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">    pre-&gt;next = q;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="头插法（原地逆转链表）"><a href="#头插法（原地逆转链表）" class="headerlink" title="头插法（原地逆转链表）"></a>头插法（原地逆转链表）</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/24/3b83e7357826fd11.png"></p>
<p>在勾画的绿色部分正是逆置的核心出装，将新插入的结点（在原链表中更靠后）不断放前，而实现逆置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListReserve</span><span class="params">(LinkList L)</span>{</span><br><span class="line">    <span class="comment">//分配一个辅助头结点</span></span><br><span class="line">    LinkList head = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">        LNode *p = L-&gt;next;</span><br><span class="line">        L-&gt;next = L-&gt;next-&gt;next;</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">    }</span><br><span class="line">    L-&gt;next = head-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(head); <span class="comment">//释放辅助头结点</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="尾插法保持原序"><a href="#尾插法保持原序" class="headerlink" title="尾插法保持原序"></a>尾插法保持原序</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/24/701497efb2b58b5e.png"></p>
<p>以下是我自己写的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListPart</span><span class="params">(LinkList C)</span>{</span><br><span class="line">    LinkList A=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode))<span class="comment">//A和B的头结点来也</span></span><br><span class="line">    LinkList B=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode))</span><br><span class="line">    A-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    B-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;<span class="comment">//计数器：判断奇偶结点</span></span><br><span class="line">    LNode *q=A;<span class="comment">//A的尾指针</span></span><br><span class="line">    <span class="keyword">while</span>(C-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">1</span>)<span class="comment">//若为奇数，尾插法</span></span><br><span class="line">        {</span><br><span class="line">            LNode*p=C-&gt;next;<span class="comment">//记录目前要拆掉的结点</span></span><br><span class="line">            C-&gt;next=C-&gt;next-&gt;next;<span class="comment">//断开该结点</span></span><br><span class="line">            q-&gt;next=p;<span class="comment">//插入尾结点之后</span></span><br><span class="line">            p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//断掉和原表最后的联系</span></span><br><span class="line">            q=p;<span class="comment">//更新尾指针</span></span><br><span class="line">            count++;<span class="comment">//更新计数值</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)<span class="comment">//若为偶数，头插法</span></span><br><span class="line">        {</span><br><span class="line">        	LNode *p = C-&gt;next;<span class="comment">//记录目前要拆掉的结点</span></span><br><span class="line">      	    L-&gt;next = C-&gt;next-&gt;next;<span class="comment">//断开该结点</span></span><br><span class="line">     	    p-&gt;next = B-&gt;next;<span class="comment">//将最新的结点插到最头边，保证逆序</span></span><br><span class="line">        	B-&gt;next = p;<span class="comment">//作为头结点的下一个结点</span></span><br><span class="line">            count++;<span class="comment">//更新计数值</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(C);<span class="comment">//正式消灭C表</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="前-中-后序遍历"><a href="#前-中-后序遍历" class="headerlink" title="前/中/后序遍历"></a>前/中/后序遍历</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/25/8766c585666172ae.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点定义（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>{</span></span><br><span class="line">    <span class="type">int</span> data;    <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左、右孩子指针</span></span><br><span class="line">}BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span> <span class="params">(BiTree root)</span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    visit(root);  <span class="comment">//访问根节点</span></span><br><span class="line">    PreOrder(root-&gt;lchild);</span><br><span class="line">    PreOrder(root-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span> <span class="params">(BiTree root)</span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrder(root-&gt;lchild);</span><br><span class="line">    visit(root);  <span class="comment">//访问根节点</span></span><br><span class="line">    InOrder(root-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span> <span class="params">(BiTree root)</span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostOrder(root-&gt;lchild);</span><br><span class="line">    PostOrder(root-&gt;rchild);</span><br><span class="line">    visit(root);  <span class="comment">//访问根节点</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>在层序遍历中需要使用到队列，也就需要队列的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(Queue &amp;Q)</span> </span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(Queue Q)</span> </span><br><span class="line"><span class="comment">//新元素x入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(Queue &amp;Q, BiTNode * x)</span> </span><br><span class="line"><span class="comment">//队头元素出队，并使用x 返回队头元素 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(Queue &amp;Q, BiTNode * &amp;x)</span><span class="comment">//&amp;x 表示引用参数，函数内部对x的修改会影响外部的x</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>{</span><br><span class="line">    Queue Q;</span><br><span class="line">    InitQueue(Q);    <span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q, T);    <span class="comment">//将根结点入队</span></span><br><span class="line">	<span class="keyword">while</span>(!IsEmpty(Q)){</span><br><span class="line">    	DeQueue(Q, p);</span><br><span class="line">    	visit(p);</span><br><span class="line">    	<span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        	EnQueue(Q, p-&gt;lchild); <span class="comment">//左孩子入队</span></span><br><span class="line">    	<span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        	EnQueue(Q, p-&gt;rchild); <span class="comment">//右孩子入队</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="求树高"><a href="#求树高" class="headerlink" title="求树高"></a>求树高</h2><h3 id="（方法一）先序遍历"><a href="#（方法一）先序遍历" class="headerlink" title="（方法一）先序遍历"></a>（方法一）先序遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求树的高度（方法一）*/</span></span><br><span class="line"><span class="type">int</span> height = <span class="number">0</span>;    <span class="comment">//用全局变量记录树的高度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; height)</span><br><span class="line">        height = n;    <span class="comment">//更新树的高度</span></span><br><span class="line">    PreOrder(T-&gt;lchild, n + <span class="number">1</span>);    <span class="comment">//遍历左子树</span></span><br><span class="line">    PreOrder(T-&gt;rchild, n + <span class="number">1</span>);    <span class="comment">//遍历右子树</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>调用时用**<code>PreOrder(T, 1</code>**)</p>
<p>原理是每过一层则+1并和目前高度比较</p>
<h3 id="（方法二）后序遍历"><a href="#（方法二）后序遍历" class="headerlink" title="（方法二）后序遍历"></a>（方法二）后序遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = PostOrder(T-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> right = PostOrder(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) </span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><img src="https://s3.bmp.ovh/imgs/2025/08/25/230bc34dea6966e2.png"></p>
<p>以该图为例，g和h没有左右结点了，故直接返回0+1给e作为e的left和right，e再进行比较以大的深度+1作为自己的深度交给b，b也这么做并和c一起交给a</p>
<p>后序遍历以孩子出发从孩子开始数并返给根节点最长的版本</p>
<h2 id="求树宽"><a href="#求树宽" class="headerlink" title="求树宽"></a>求树宽</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/25/68f6fe2304759243.png"></p>
<p>此处先用先序遍历统计每一层的结点数，也就是使用先序遍历先根后孩子的特点来统计</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> width[MAX];  <span class="comment">//用于统计各层的结点总数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历，同时统计各层结点总数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T, <span class="type">int</span> level)</span> {</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    width[level]++;  <span class="comment">//累加该层结点总数</span></span><br><span class="line">    PreOrder(T-&gt;lchild, level + <span class="number">1</span>);  <span class="comment">//遍历左子树</span></span><br><span class="line">    PreOrder(T-&gt;rchild, level + <span class="number">1</span>);  <span class="comment">//遍历右子树</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>再找到宽度数组中最大的一项，将其作为树宽</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">treeWidth</span><span class="params">(BiTree T)</span> {</span><br><span class="line">    <span class="comment">// 初始化宽度数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">        width[i] = <span class="number">0</span>;</span><br><span class="line">    PreOrder(T, <span class="number">0</span>);  <span class="comment">// 从第0层开始遍历</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出最大宽度（某一层最多的节点数）</span></span><br><span class="line">    <span class="type">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) {</span><br><span class="line">        <span class="keyword">if</span> (width[i] &gt; maxWidth)</span><br><span class="line">            maxWidth = width[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树的宽度是%d"</span>, maxWidth);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="求树WPL"><a href="#求树WPL" class="headerlink" title="求树WPL"></a>求树WPL</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/25/840b545681b07964.png"></p>
<p>求树的WPL还是要使用树的先序遍历</p>
<p>使用了求树高和树宽的思想</p>
<p>先找到叶子节点（也就是左右孩子为空）并且将此处的带权路径长度加入WPL</p>
<p>如果不是叶子结点则向下找到其他叶子节点高度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span> <span class="params">(BiTree T, <span class="type">int</span> level)</span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">    WPL += level*T-&gt;weight; <span class="comment">//累加叶结点带权路径长度</span></span><br><span class="line">    PreOrder(T-&gt;lchild, level + <span class="number">1</span>); <span class="comment">//遍历左子树</span></span><br><span class="line">    PreOrder(T-&gt;rchild, level + <span class="number">1</span>); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h1 id="特殊树型判断"><a href="#特殊树型判断" class="headerlink" title="特殊树型判断"></a>特殊树型判断</h1><h2 id="二叉排序树判定"><a href="#二叉排序树判定" class="headerlink" title="二叉排序树判定"></a>二叉排序树判定</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/25/1825ad153c697882.png"></p>
<p>中序遍历出来的序列是升序序列，所以二叉排序树序列中下一个结点必然大于前面所有的结点（也就是MAX{前面结点}）这里用temp表示</p>
<p>所以只要后面遍历到的小于temp，则直接判定失败</p>
<p>若不小于则继续向右子树遍历，直到为NULL退回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp=MIN_INT; <span class="comment">//记录当前遍历到的最小值</span></span><br><span class="line"><span class="type">bool</span> isBST=<span class="literal">true</span>;    <span class="comment">//是否为二叉排序树？</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    InOrder(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data &gt;= temp)    temp=T-&gt;data;</span><br><span class="line">    <span class="keyword">else</span>    isBST=<span class="literal">false</span>;</span><br><span class="line">    InOrder(T-&gt;rchild);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉树判定"><a href="#平衡二叉树判定" class="headerlink" title="平衡二叉树判定"></a>平衡二叉树判定</h2><p><img src="https://s3.bmp.ovh/imgs/2025/08/25/f598941d10a33749.png"></p>
<p>此树判定和方法二找树深一样</p>
<p>通过后序遍历的特点：先访问孩子再进行操作，由最后的孩子也就是结点A的左右子树都退回来自己的高度之后，再进行左右子树高度判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isBalance=<span class="literal">true</span>;    <span class="comment">//二叉树是否平衡</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = PostOder(T-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> right = PostOder(T-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left-right&gt;<span class="number">1</span>)    isBalance=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (left-right&lt;<span class="number">-1</span>)    isBalance=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//树的深度=Max(左子树深度，右子树深度)+1</span></span><br><span class="line">    <span class="keyword">if</span> (left&gt;right)   <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="完全二叉树判定"><a href="#完全二叉树判定" class="headerlink" title="完全二叉树判定"></a>完全二叉树判定</h2><p>这里先借用一下层序遍历的图</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/25/25b14ee34e04a792.png"></p>
<p>层序遍历，因为完全二叉树是按顺序排放，所以要看每一层的结点的逐个讨论、</p>
<p>四种情况分别在访问这个结点时讨论一次</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/25/069c0a1411d4d154.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊树形判定：完全二叉树？</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isComplete = <span class="literal">true</span>;    <span class="comment">// 是否为完全二叉树</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;         <span class="comment">// flag=true，表示层序遍历时出现过叶子或只有左孩子的分支节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode * p)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">// 当前节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) {</span><br><span class="line">            isComplete = <span class="literal">false</span>;  <span class="comment">// 不是完全二叉树</span></span><br><span class="line">        }</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">// 只有左孩子，没有右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (flag) {</span><br><span class="line">            isComplete = <span class="literal">false</span>;  <span class="comment">// 不是完全二叉树</span></span><br><span class="line">        }</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">// 只有右孩子，没有左孩子 - 肯定不是完全二叉树</span></span><br><span class="line">        isComplete = <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 有两个孩子</span></span><br><span class="line">        <span class="keyword">if</span> (flag) {</span><br><span class="line">            isComplete = <span class="literal">false</span>;  <span class="comment">// 不是完全二叉树</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p><img src="https://s3.bmp.ovh/imgs/2025/08/25/16392d4c271b9418.png"></p>
<h2 id="图的数据结构定义"><a href="#图的数据结构定义" class="headerlink" title="图的数据结构定义"></a>图的数据结构定义</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>这是邻接矩阵的数据结构</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/25/8dfd61076cd026ce.png"></p>
<p>这是邻接矩阵的初始化操作</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/25/da3f1d32966513b0.png"></p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>这是邻接表的数据结构，在图ALGraph中存储一个顶点表数组和顶点数和边数</p>
<p>在顶点表中存储这个结点的数据和第一个依附该点的边</p>
<p>边表则是指出这条边指向的点和<strong>下一条边的指针</strong>以及该边权值</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/25/ab8f9856d35c6f5a.png"></p>
<p>这个表依旧要执行初始化操作</p>
<p>先将顶点表数组中的第一条边全部置为NULL</p>
<p>再将其顶点数和边数先更新</p>
<p>用封装好的AddEdge(图,出点，入点，权值)函数添加边</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/25/32c46cbe2105b671.png"></p>
<p>AddEdge函数是这么写的</p>
<p>首先先创建一个边结点，将其的权值和指向的结点j配置好</p>
<p>再将他连接到i结点第一条边之前，让这条新边指向老的第一条边（类似头插法将靠后的插在头边）</p>
<p>最后让i的点表连接到这条边作为first</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/25/cd466d9d1b1a6548.png"></p>
<p>最后可以看到他的逻辑结构长这样</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/26/3eea91a06fa325b7.png"></p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p><img src="https://s3.bmp.ovh/imgs/2025/08/26/e7d293c50f73edd8.png" alt="里昂学长的pdf"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵实现深度优先搜索</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(MGraph G,<span class="type">int</span> i)</span>{</span><br><span class="line">    visit(i);</span><br><span class="line">    <span class="comment">//访问初始顶点</span></span><br><span class="line">    visited[i]=<span class="literal">true</span>;<span class="comment">//对做已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.G.numVertices;j++)</span><br><span class="line">    <span class="keyword">if</span>(visited[j]==<span class="literal">false</span>&amp;&amp;G.edge[i][j]==<span class="number">1</span>){</span><br><span class="line">    DFS(G,j);<span class="comment">//为的尚未访问的邻接点，递归访问</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>首先先把第一个访问的结点打上true，对第一结点比如A，找他向别人发射过的边，直到j&lt;G.vexnum（穷尽了所有点）</p>
<p>当遇到没有遍历到过的且存在的邻接点时，将其投入DPS</p>
<p>然后一直DPS递归下去，直到再没有邻接的点，逐层返回没有访问完邻接点的结点中继续访问他们邻接点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表实现深度优先搜索</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(ALGraph G,<span class="type">int</span> i)</span>{</span><br><span class="line">    visit(i);</span><br><span class="line">    <span class="comment">//访问初始顶点</span></span><br><span class="line">    visited[i]=<span class="literal">true</span>;<span class="comment">//对做已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(EdgeNode* p=G.VertexList[i].first ; p!=<span class="literal">NULL</span>; p=p-&gt;next){</span><br><span class="line">    <span class="comment">//检测的所有邻接点</span></span><br><span class="line">    <span class="type">int</span> j=p-&gt;index;</span><br><span class="line">    <span class="keyword">if</span>(visited[j]==<span class="literal">false</span>){</span><br><span class="line">    DFS(G,j);<span class="comment">//为的尚未访问的邻接点，递归访问</span></span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>前面步骤一样，依旧从i点开始遍历。先找到i点的第一个边，将其位置存放到p中</p>
<p>j就是此时p指向的点，若此点没有被访问过则开始深度遍历</p>
<p>直到遍历到最后一个能遍历到的点，就往上返回，继续访问之前没有访问完其他边的结点。</p>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p><img src="https://s3.bmp.ovh/imgs/2025/08/26/c5d95beba5f7504e.png" alt="里昂学长的pdf"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵实现广度优先搜索</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(MGraph G, <span class="type">int</span> v)</span>{</span><br><span class="line">    visit(v); <span class="comment">//访问初始顶点</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>; <span class="comment">//对v做已访问标记</span></span><br><span class="line">    EnQueue(Q, v); <span class="comment">//顶点v入队</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q)){</span><br><span class="line">        DeQueue(Q, v); <span class="comment">//从队首取出顶点v</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">0</span>; w&lt;G.numVertices; w++){</span><br><span class="line">            <span class="comment">//检测v的所有邻接顶点</span></span><br><span class="line">            <span class="keyword">if</span>(visited[w]==<span class="literal">false</span> &amp;&amp; G.edge[v][w]==<span class="number">1</span>){</span><br><span class="line">                visit(w); <span class="comment">//w为v的尚未访问的邻接点，访问w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>; <span class="comment">//标记w为已访问</span></span><br><span class="line">                EnQueue(Q, w); <span class="comment">//顶点w入队</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>广度优先遍历类似于图的层序遍历</p>
<p>从v出发，先将v存入队列中</p>
<p>当队列不为空时就出队一个结点，并且从第0个结点开始遍历，寻找v指向的且没有被访问过的结点，找到一个入队一个直到找不到为止</p>
<p>然后从i结点找到的第一个结点开始继续重复这个步骤，直到所有结点都找完使队列为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表实现广度优先搜索</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(ALGraph G, <span class="type">int</span> v)</span>{</span><br><span class="line">    visit(v); <span class="comment">//访问初始顶点</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>; <span class="comment">//对v做已访问标记</span></span><br><span class="line">    EnQueue(Q, v); <span class="comment">//顶点v入队</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q)){</span><br><span class="line">        DeQueue(Q, v); <span class="comment">//从队首取出顶点v</span></span><br><span class="line">        <span class="keyword">for</span>(EdgeNode *p=G.VertexList[v].first; p!=<span class="literal">NULL</span>; p=p-&gt;next){</span><br><span class="line">            <span class="comment">//检测v的所有邻接顶点</span></span><br><span class="line">            <span class="type">int</span> w = p-&gt;index;</span><br><span class="line">            <span class="keyword">if</span>(visited[w]==<span class="literal">false</span>){</span><br><span class="line">                visit(w); <span class="comment">//w为v的尚未访问的邻接点，访问w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>; <span class="comment">//标记w为已访问</span></span><br><span class="line">                EnQueue(Q, w); <span class="comment">//顶点w入队</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>套路和上面一样，入队之后先找到第一个边指向的结点看是否被访问过，若没有则全部入队直到v结点没有邻接的点为止。</p>
<p>然后又从v第一条边邻接点继续广度优先遍历</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>先按一下思路分析</p>
<p>拓扑排序的步骤:</p>
<ol>
<li>选择入度为0的顶点并输出</li>
<li>从图中删除该顶点与所有以它为弧的边</li>
<li>重复步骤1、2，直到不存在入度为0的顶点</li>
</ol>
<table>
<thead>
<tr>
<th>拓扑序列</th>
<th>条件</th>
</tr>
</thead>
<tbody><tr>
<td>存在且唯一</td>
<td>每次选择结点都只有一个结点可选</td>
</tr>
<tr>
<td>存在不唯一</td>
<td>选择结点时不止一个结点可选</td>
</tr>
<tr>
<td>不存在</td>
<td>图中有环，环中顶点未被访问</td>
</tr>
</tbody></table>
<p>先拿王道的流程图说一下思想</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/08/26/6616dd51d5490c85.png"></p>
<p>首先我们需要循环找到入度为0的点并且全部入队。</p>
<p>此处如果队列里元素个数超过1，</p>
<ul>
<li>入度为0的点肯定超过2个也就是拓扑排序不唯一。</li>
<li>若是有多个连通分量，一个连通分量多个入度为0，另一个连通分量是有环图，则很明显不存在拓扑排序</li>
</ul>
<p>然后当我们出队时，我们将计数器+1，来记录已经出队的数</p>
<p>出队之后将所有出队的点指向的点，把他们的入度-1，然后继续寻找入度为0的点循环这个过程</p>
<p>当队空之后我们根据count数进行判断</p>
<ul>
<li><strong>如果count等于顶点数，那么说明从顶点到最后一个点只有一条路径。没错，拓扑排序唯一</strong></li>
<li><strong>若count数不等于也就是小于顶点数，说明存在环路，始终有点入度不为0互相堵着</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uniquely1</span><span class="params">(MGraph G)</span>{</span><br><span class="line">    <span class="type">int</span> inDegree[MAXV] = {<span class="number">0</span>}; <span class="comment">// 存储每个顶点的入度</span></span><br><span class="line">	<span class="type">int</span> <span class="built_in">queue</span>[MAXV];    <span class="comment">// 用于存储入度为0的顶点</span></span><br><span class="line">	<span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;    <span class="comment">// 队列的前后指针</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;    <span class="comment">// 拓扑序列中的顶点计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算每个顶点的入度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	{</span><br><span class="line">    	ArcNode *p = G.AdjList[i].firstarc;<span class="comment">//从i的第一条边开始找</span></span><br><span class="line">    	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    	{</span><br><span class="line">        	inDegree[p-&gt;adjvex]++;</span><br><span class="line">        	p = p-&gt;nextarc;</span><br><span class="line">    	}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有入度为0的顶点入队</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	{</span><br><span class="line">    	<span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">        	<span class="built_in">queue</span>[rear++] = i;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行拓扑排序</span></span><br><span class="line">	<span class="keyword">while</span> (front &lt; rear)<span class="comment">//非空队列</span></span><br><span class="line">	{</span><br><span class="line">    	<span class="comment">// 如果队列中有多个顶点，说明图的拓扑序列不唯一</span></span><br><span class="line">    	<span class="keyword">if</span> (rear - front &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> v = <span class="built_in">queue</span>[front++]; <span class="comment">// 取出队首顶点</span></span><br><span class="line">    	count++;</span><br><span class="line">    	<span class="comment">// 更新该顶点的所有邻接顶点的入度</span></span><br><span class="line">    	ArcNode *p = G.AdjList[v].firstarc;</span><br><span class="line">    	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    	{</span><br><span class="line">        	inDegree[p-&gt;adjvex]--;</span><br><span class="line">        	<span class="comment">// 如果入度变为0，则加入队列</span></span><br><span class="line">        	<span class="keyword">if</span> (inDegree[p-&gt;adjvex] == <span class="number">0</span>)</span><br><span class="line">            	<span class="built_in">queue</span>[rear++] = p-&gt;adjvex;</span><br><span class="line">        	p = p-&gt;nextarc;</span><br><span class="line">    	}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count == G.vexnum)</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 当前拓扑序列包含所有顶点，则图的拓扑序列唯一</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当前拓扑序列不包含所有顶点，则图的拓扑序列不存在</span></span><br><span class="line">}</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uniquely1</span><span class="params">(MGraph G)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> inDegree[MAXV] = {<span class="number">0</span>}; <span class="comment">// 存储每个顶点的入度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">queue</span>[MAXV]; <span class="comment">// 用于存储入度为0的顶点</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>; <span class="comment">// 队列的前后指针</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 拓扑序列中的顶点计数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算每个顶点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numVertices; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.numVertices; j++)</span><br><span class="line">            <span class="keyword">if</span> (G.Edge[i][j] != <span class="number">0</span>)</span><br><span class="line">                inDegree[j]++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将所有入度为0的顶点入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numVertices; i++)</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">queue</span>[rear++] = i;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行拓扑排序</span></span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 如果队列中有多个顶点，说明图的拓扑序列不唯一</span></span><br><span class="line">        <span class="keyword">if</span> (rear - front &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">queue</span>[front++]; <span class="comment">// 取出队首顶点</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 更新该顶点的所有邻接顶点的入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numVertices; i++)</span><br><span class="line">            <span class="keyword">if</span> (G.Edge[v][i] != <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                inDegree[i]--; <span class="comment">// 如果入度变为0，则加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">queue</span>[rear++] = i;</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (count == G.numVertices)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 当前拓扑序列包含所有顶点，则图的拓扑序列唯一</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当前拓扑序列不包含所有顶点，则图的拓扑序列不存在</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="叶落归"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">叶落归</p>
  <div class="site-description" itemprop="description">”我这辈子一直想信仰某种东西，“圣地亚哥说道,”然而却一直在撒谎，我没有信仰“</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yeluogui233" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yeluogui233" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1399099158@qq.com" title="E-Mail → 1399099158@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6553184492" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6553184492" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="/yeluoguihhh@gmail.com" title="Google → yeluoguihhh@gmail.com"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/yeluo_gui" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;yeluo_gui" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/@%E5%8F%B6%E8%90%BD%E5%BD%92" title="YouTube → https:&#x2F;&#x2F;www.youtube.com&#x2F;@%E5%8F%B6%E8%90%BD%E5%BD%92" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://steamcommunity.com/id/yeluogui/" title="https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;yeluogui&#x2F;" rel="noopener" target="_blank">steam主页(欢迎扩列)</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://store.steampowered.com/curator/36773728/" title="https:&#x2F;&#x2F;store.steampowered.com&#x2F;curator&#x2F;36773728&#x2F;" rel="noopener" target="_blank">延燃游戏鉴赏家</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tieba.baidu.com/f?kw=minecraft%E5%9B%BE%E6%96%87&fp=0" title="https:&#x2F;&#x2F;tieba.baidu.com&#x2F;f?kw&#x3D;minecraft%E5%9B%BE%E6%96%87&amp;fp&#x3D;0" rel="noopener" target="_blank">minecraft图文吧</a>
        </li>
    </ul>
  </div>

      </div><div>
  <canvas id="canvasDiyBlock" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
<script src="/js/clock.js"></script>

</div>


    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <!-- Footer -->
<div class="footer-wrapper" style="text-align:center; font-size:14px; color:#222; max-width:900px; margin:auto; padding:20px 0;">

  <!-- 第一行：版权 + 总字数 + 阅读时间 -->
  <div class="footer-line footer-line-1" style="display:flex; justify-content:center; align-items:center; gap:12px; flex-wrap:wrap;">
    <span>© 2026 <span style="color:#e25555;">&#10084;</span> 叶落归</span>

    <i class="fa-solid fa-file-lines" style="color:#000;"></i>
    <span>总字数: <span id="local_word_count">0</span></span>

    <i class="fa-regular fa-clock" style="color:#000;"></i>
    <span>预计阅读时间: <span id="local_read_time">0</span> 分钟</span>
  </div>

  <!-- 第二行：驱动信息 -->
  <div class="footer-line footer-line-2" style="margin-top:10px; color:#555; font-size:13px;">
    由 
    <a href="https://hexo.io" target="_blank" rel="noopener" style="color:#555; text-decoration:none; font-weight:600;">Hexo</a>
    &amp;
    <a href="https://theme-next.org/" target="_blank" rel="noopener" style="color:#555; text-decoration:none; font-weight:600;">NexT.Gemini</a>
    强力驱动
  </div>

  <!-- 第三行：访客数 | 浏览量 -->
  <div class="footer-line footer-line-3" style="margin-top:15px; display:flex; justify-content:center; gap:30px; font-size:14px; color:#222;">
    <div style="display:flex; align-items:center; gap:6px;">
      <i class="fa-regular fa-eye" style="color:#000; font-size:18px;"></i>
      <span>访客数 <span id="local_uv_count">0</span></span>
    </div>
    <div style="display:flex; align-items:center; gap:6px;">
      <i class="fa-solid fa-user" style="color:#000; font-size:18px;"></i>
      <span>浏览量 <span id="local_pv_count">0</span></span>
    </div>
  </div>

</div>

<!-- 本地统计脚本 -->
<script>
(function() {
  const pvKey = 'local_pv_count';
  const uvKey = 'local_uv_count';
  const uvFlagKey = 'local_uv_flag';

  let pvCount = parseInt(localStorage.getItem(pvKey)) || 0;
  let uvCount = parseInt(localStorage.getItem(uvKey)) || 0;

  // PV 每次访问+1
  pvCount++;
  localStorage.setItem(pvKey, pvCount);

  // UV 仅第一次访问+1
  if (!localStorage.getItem(uvFlagKey)) {
    uvCount++;
    localStorage.setItem(uvKey, uvCount);
    localStorage.setItem(uvFlagKey, 'true');
  }

  document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('local_pv_count').textContent = pvCount.toLocaleString();
    document.getElementById('local_uv_count').textContent = uvCount.toLocaleString();

    const content = document.querySelector('.main-inner');
    const text = content ? (content.innerText || content.textContent) : '';
    const length = text.trim().length;

    document.getElementById('local_word_count').textContent = length.toLocaleString();
    document.getElementById('local_read_time').textContent = Math.ceil(length / 200);
  });
})();
</script>

<!-- 确保在 head 里引入 Font Awesome -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<!-- 网易云播放器 -->
<div id="netease-player">
  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0"
    width="330" height="86"
    src="//music.163.com/outchain/player?type=2&id=2006472583&auto=1&height=66">
  </iframe>
</div>

<!-- Sakana Widget 容器 -->
<div id="sakana-widget-container">
  <div id="sakana-widget"></div>
</div>

<style>
  #netease-player {
    position: fixed;
    left: 20px;
    bottom: 20px;
    z-index: 99998;
  }
  #sakana-widget-container {
    position: fixed;
    left: 20px;
    bottom: 120px; /* 让出网易云播放器空间 */
    z-index: 99999;
    width: 180px !important;
    height: 180px !important;
    pointer-events: auto;
  }
  #sakana-widget-container img {
    image-rendering: auto;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
</style>

<script>
  // 动态加载 Sakana Widget CSS
  const sakanaCss = document.createElement('link');
  sakanaCss.rel = 'stylesheet';
  sakanaCss.href = 'https://cdn.jsdelivr.net/npm/sakana-widget@2.7.1/lib/sakana.min.css';
  document.head.appendChild(sakanaCss);

  // 动态加载 Sakana Widget JS 并初始化
  const sakanaJs = document.createElement('script');
  sakanaJs.src = 'https://cdn.jsdelivr.net/npm/sakana-widget@2.7.1/lib/sakana.min.js';
  sakanaJs.onload = function() {
    // 取默认角色
    const chisato = SakanaWidget.getCharacter('chisato');
    const takina = SakanaWidget.getCharacter('takina');

    // 自定义角色1
    const custom1 = SakanaWidget.getCharacter('chisato');
    custom1.image = 'https://s3.bmp.ovh/imgs/2025/08/03/f245f413052bd146.png';
    SakanaWidget.registerCharacter('custom1', custom1);

    // 自定义角色2
    const custom2 = SakanaWidget.getCharacter('chisato');
    custom2.image = 'https://s3.bmp.ovh/imgs/2025/08/03/0c2a35fe5337492e.png';
    SakanaWidget.registerCharacter('custom2', custom2);

    // 按顺序放入数组，先显示 custom1
    const charactersOrder = ['custom1', 'custom2', 'chisato', 'takina'];
    
    // 创建实例，初始角色 custom1
    const widget = new SakanaWidget({
      size: 180,
      controls: true,
      draggable: true,
      rod: true,
      character: charactersOrder[0],
    }).mount('#sakana-widget');

    // 重写切换角色逻辑，让切换顺序符合 charactersOrder
    let currentIdx = 0;
    const origNextCharacter = widget.nextCharacter.bind(widget);
    widget.nextCharacter = () => {
      currentIdx = (currentIdx + 1) % charactersOrder.length;
      widget.setCharacter(charactersOrder[currentIdx]);
    };

    // 绑定底座切换按钮的事件，使它调用新的 nextCharacter
    // 这里监听控件切换角色按钮点击（默认控件中左侧切换按钮 class 名可在控制台查看）
    // 也可以全局捕获键盘事件实现切换
    // 这里用简单轮换逻辑替代默认方法
  };
  document.body.appendChild(sakanaJs);
</script>

<style>
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script>
<script src="/libs/codeBlock/codeBlockFuction.js"></script>
<script src="/libs/codeBlock/codeLang.js"></script>
<script src="/libs/codeBlock/codeCopy.js"></script>
<script src="/libs/codeBlock/clipboard.min.js"></script>
<script src="/libs/codeBlock/codeShrink.js"></script>
<script>
// 为文章内容中的所有外部链接生成卡片
document.addEventListener('DOMContentLoaded', function() {
  var postContent = document.querySelector('.post-body') || 
                    document.querySelector('.post-block') ||
                    document.querySelector('.entry-content');
  if (postContent) {
    var externalLinks = postContent.querySelectorAll('a[target="_blank"]');
    if (externalLinks.length > 0) {
      cardLink(externalLinks);
    }
  }
});
</script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"react":{"opacity":0.7},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
